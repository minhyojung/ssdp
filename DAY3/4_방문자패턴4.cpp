// 방문자 패턴의 의미!!
class Shape
{
public:
	virtual void Draw() = 0;

	virtual void Move() = 0; // 가상함수의 추가
};
class Rect : public Shape {};
class Circle : public Shape {};

// 전통적인 객체지향 디자인 - ? 자리에 (1). 쉽다  (2). 어렵다 로 채워 보세요.
// 클래스의 추가    :  쉽다( 다형성 기반으로 잘 설계 했다면..)
// 가상 함수(오퍼레이션)의 추가 :  어렵다. 기존의 모든 도형이
//								수정되어야 한다.




// 그런데, Move()라는 가상함수를 추가하지말고!!
ShapeMoveVisitor v;
컨테이너.accept(&v); // 이렇게 하면 ??


// 방문자 패턴으로 디자인 하면
// 클래스의 추가   : 어려워 진다.(새로운 메뉴가 추가될때 
//								IMenuVisitor 를 생각해 보세요

// 가상 함수의 추가 : 쉬워진다.(진짜 가상함수의 추가가 아니라
//					가상함수가 해야할 일을 방문자로 설계)

// 방문자를 사용하면 
// => 대부분 방문대상의 멤버데이타를 접근하게 됩니다.
//    private 등에 접근이 안되므로
//    set_title() 같은 함수가 제공되어야 합니다.
//    객체의 완벽한 은닉이 안됨



